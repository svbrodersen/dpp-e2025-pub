\section{2D Ising Model}\label{sec:_d_ising_model} % (fold)
\subsection{Generate initial state}\label{sub:generate_initial_state} % (fold)
The function for the random grid can be seen below
\begin{lstlisting}[language={futhark}]
def random_grid (seed: i32) (h: i64) (w: i64)
              : ([h][w]rng_engine.rng, [h][w]spin) =
  let initial = rng_engine.rng_from_seed [seed]
  let states_flat = rng_engine.split_rng (h * w) initial
  let (new_states, spins) = map (\r -> 
    let (r, i) = rand_i8.rand (0, 1i8) r
    in if i == 0 then (r, -1) else (r, i)
    ) states_flat |> unzip
  in (unflatten new_states, unflatten spins)
\end{lstlisting}

We generate the random state by splitting an initial state into $h * w$ new
states. Then we can randomly generate -1 or 1, and return the new random states
that are also generated by rand\_i8.

\subsection{Computing Delta}\label{sub:computing_delta} % (fold)
The code for computing the deltas can be seen below:
\begin{lstlisting}[language={futhark}]
def deltas [h][w] (spins: [h][w]spin): [h][w]i8 =
   let rot_down = rotate 1 spins |> flatten
   let rot_up = rotate (-1) spins |> flatten
   let rot_left = map (rotate (-1)) spins |> flatten
   let rot_right = map (rotate (1)) spins |> flatten
   -- for spins[i, j] then l is rot_right[i, j]
   let res = map5 (\c u d l r -> 2 * c * (u + d + l + r)) 
                  (flatten spins) 
                  rot_down 
                  rot_up 
                  rot_right 
                  rot_left
   in unflatten res
\end{lstlisting}

Here we make use of the rotate to rotate in each of the different directions.
Then using a single map with the 5 inputs we simply calculate the deltas via.
the formula provided.

\subsection{The step function}\label{sub:the_step_function} % (fold)
The step function is provided below:
\begin{lstlisting}[language={futhark}]
def step [h][w] (abs_temp: f32) (samplerate: f32)
                (rngs: [h][w]rng_engine.rng) (spins: [h][w]spin)
              : ([h][w]rng_engine.rng, [h][w]spin) =
  let delta_es = deltas spins |> flatten |> map (f32.i8)
  let (new_states, new_spins) = map3 (\r1 c delta_e ->
    let neg_delta_e = - delta_e
    let (r2, a) = rand_f32.rand (0f32, 1f32) r1 
    let (new_r, b) = rand_f32.rand (0f32, 1f32) r2
    let pow_e = f32.exp (neg_delta_e / abs_temp)
    in
      if (a < samplerate) && ((delta_e < neg_delta_e) || (b < pow_e)) then 
        (new_r, -c)
      else 
        (new_r, c)
  ) (flatten rngs) (flatten spins) delta_es |> unzip
  in (unflatten new_states, unflatten new_spins)
\end{lstlisting}
First we compute the deltas using the aforementioned function. Inside a map we
then follow directly the calculations provided by generating random values a
and b between 0 and 1. Here it is important to note, that b is created using
the new random state returned after creating b and also the random state we are
returning is an unused new random state returned from generating b.

\subsection{Benchmarking}\label{sub:benchmarking_sing} % (fold)
\begin{table}[htbp]
\centering
\caption{Performance comparison of Ising model implementations with speedup relative to sequential baseline}
\label{tab:ising_performance}
\begin{tabular}{rrr|rrr|rr}
\hline
\multicolumn{3}{c|}{\textbf{Parameters}} & \multicolumn{3}{c|}{\textbf{Runtime ($\mu$s)}} & \multicolumn{2}{c}{\textbf{Speedup}} \\
\textbf{h} & \textbf{w} & \textbf{n} & \textbf{OpenCL} & \textbf{Sequential} & \textbf{Multicore} & \textbf{OpenCL} & \textbf{Multicore} \\
\hline
100 & 10 & 2 & 64 & 113 & 2,354 & 1.77$\times$ & 0.05$\times$ \\
1,000 & 10 & 2 & 67 & 1,284 & 2,603 & 19.16$\times$ & 0.49$\times$ \\
10,000 & 10 & 2 & 92 & 13,624 & 6,671 & 148.09$\times$ & 2.04$\times$ \\
100,000 & 10 & 2 & 158 & 127,852 & 50,458 & 809.19$\times$ & 2.53$\times$ \\
\hline
10 & 10 & 2 & 67 & 11 & 1,187 & 0.16$\times$ & 0.01$\times$ \\
10 & 100 & 2 & 63 & 106 & 2,333 & 1.68$\times$ & 0.05$\times$ \\
10 & 1,000 & 2 & 66 & 1,173 & 1,795 & 17.77$\times$ & 0.65$\times$ \\
10 & 10,000 & 2 & 85 & 11,843 & 8,752 & 139.33$\times$ & 1.35$\times$ \\
10 & 100,000 & 2 & 150 & 121,386 & 71,967 & 809.24$\times$ & 1.69$\times$ \\
\hline
10 & 10 & 10 & 229 & 56 & 1,379 & 0.24$\times$ & 0.04$\times$ \\
10 & 10 & 100 & 2,099 & 549 & 1,042 & 0.26$\times$ & 0.53$\times$ \\
10 & 10 & 1,000 & 19,803 & 5,103 & 8,057 & 0.26$\times$ & 0.63$\times$ \\
10 & 10 & 10,000 & 199,459 & 50,514 & 77,982 & 0.25$\times$ & 0.65$\times$ \\
10 & 10 & 100,000 & 1,979,167 & 508,566 & 739,818 & 0.26$\times$ & 0.69$\times$ \\
10 & 10 & 1,000,000 & 19,547,227 & 4,968,729 & 7,307,114 & 0.25$\times$ & 0.68$\times$ \\
\hline
\end{tabular}
\end{table}

The benchmarks can be seen in Table~\ref{tab:ising_performance}. Here we can
see that when h and w increase, then the GPU parallelisation significantly
increases the performance. However, when n increases we do not see the same
speedup. This makes sense as we simply have a sequential loop over n.

% subsection benchmarking (end)
% subsection The step function (end)
% subsection Computing Delta (end)
% subsection Generate initial state (end)
% section 2D Ising Model (end)
