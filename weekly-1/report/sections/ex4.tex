\section{2D Ising Model}\label{sec:_d_ising_model} % (fold)
\subsection{Generate initial state}\label{sub:generate_initial_state} % (fold)
The function for the random grid can be seen below
\begin{lstlisting}[language={futhark}]
def random_grid (seed: i32) (h: i64) (w: i64)
              : ([h][w]rng_engine.rng, [h][w]spin) =
  let initial = rng_engine.rng_from_seed [seed]
  let states_flat = rng_engine.split_rng (h * w) initial
  let (new_states, spins) = map (\r -> 
    let (r, i) = rand_i8.rand (0, 1i8) r
    in if i == 0 then (r, -1) else (r, i)
    ) states_flat |> unzip
  in (unflatten new_states, unflatten spins)
\end{lstlisting}

We generate the random state by splitting an initial state into $h * w$ new
states. Then we can randomly generate -1 or 1, and return the new random states
that are also generated by rand\_i8.

\subsection{Computing Delta}\label{sub:computing_delta} % (fold)
The code for computing the deltas can be seen below:
\begin{lstlisting}[language={futhark}]
def deltas [h][w] (spins: [h][w]spin): [h][w]i8 =
   let rot_down = rotate 1 spins |> flatten
   let rot_up = rotate (-1) spins |> flatten
   let rot_left = map (rotate (-1)) spins |> flatten
   let rot_right = map (rotate (1)) spins |> flatten
   -- for spins[i, j] then l is rot_right[i, j]
   let res = map5 (\c u d l r -> 2 * c * (u + d + l + r)) 
                  (flatten spins) 
                  rot_down 
                  rot_up 
                  rot_right 
                  rot_left
   in unflatten res
\end{lstlisting}

Here we make use of the rotate to rotate in each of the different directions.
Then using a single map with the 5 inputs we simply calculate the deltas via.
the formula provided.

\subsection{The step function}\label{sub:the_step_function} % (fold)
The step function is provided below:
\begin{lstlisting}[language={futhark}]
def step [h][w] (abs_temp: f32) (samplerate: f32)
                (rngs: [h][w]rng_engine.rng) (spins: [h][w]spin)
              : ([h][w]rng_engine.rng, [h][w]spin) =
  let delta_es = deltas spins |> flatten |> map (f32.i8)
  let (new_states, new_spins) = map3 (\r1 c delta_e ->
    let neg_delta_e = - delta_e
    let (r2, a) = rand_f32.rand (0f32, 1f32) r1 
    let (new_r, b) = rand_f32.rand (0f32, 1f32) r2
    let pow_e = f32.exp (neg_delta_e / abs_temp)
    in
      if (a < samplerate) && ((delta_e < neg_delta_e) || (b < pow_e)) then 
        (new_r, -c)
      else 
        (new_r, c)
  ) (flatten rngs) (flatten spins) delta_es |> unzip
  in (unflatten new_states, unflatten new_spins)
\end{lstlisting}
First we compute the deltas using the aforementioned function. Inside a map we
then follow directly the calculations provided by generating random values a
and b between 0 and 1. Here it is important to note, that b is created using
the new random state returned after creating b and also the random state we are
returning is an unused new random state returned from generating b.

\subsection{benchmarking}\label{sub:benchmarking} % (fold)
\begin{figure}
  \begin{center}
    \includegraphics[width=0.95\textwidth]{../../src/ising-handout/ising-graph.png}
  \end{center}
  \caption{}\label{fig:ising}
\end{figure}

The benchmarks can be seen in Figure~\ref{fig:ising}.

% subsection benchmarking (end)


% subsection The step function (end)


% subsection Computing Delta (end)


% subsection Generate initial state (end)
% section 2D Ising Model (end)
