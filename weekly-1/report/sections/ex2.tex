\section{Implementing prefix sum}
The hillis steele implementation can be seen below:
\begin{lstlisting}[language={futhark}]
def hillis_steele [n] (xs: [n]i32) : [n]i32 = 
  let m = ilog2 n
  in loop xs = copy xs for d in 0...m-1 do 
    let pow_2 = 1 << d
    in map (\i -> if i - pow_2 >= 0 then xs[i-(pow_2)] + xs[i] else xs[i]) (iota n)
\end{lstlisting}
This works quite intuitively as we are assuming our input is some power of 2.
First, we compute m via the provided ilog2 function. Then, in a loop given m we
map over all the indices. If an index is less than the current $2^d$, then we
simply copy the previous iteration result and otherwise we add
$xs[i-pow\_2]+xs[i]$.

This was tested as follows:
\begin{lstlisting}[language={futhark}]
-- Hillis test
-- ==
-- entry: test_hillis
-- nobench input { [0, 0, 1, 0, 0, 0, 0, 0] }
-- output { [0, 0, 1, 1, 1, 1, 1, 1] }
-- nobench input { [0, 1, 1, 0, 0, 0, 0, 0] }
-- output { [0, 1, 2, 2, 2, 2, 2, 2] }
-- nobench input { [3, 1, 7, 0, 4, 1, 6, 3] }
-- output { [3, 4, 11, 11, 15, 16, 22, 25] }
entry test_hillis = hillis_steele
\end{lstlisting}

And passes the provided tests.
